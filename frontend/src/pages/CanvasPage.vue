<script setup lang="ts">
/**
 * CanvasPage - Full canvas editor page with Vue Flow integration
 *
 * Users access this page via:
 * 1. DiagramTemplateInput - Template-based prompt input → navigates here with prompt
 * 2. DiagramTypeGrid - "在画布中创建" → navigates here with diagram type
 *
 * The "AI生成图示" button in the toolbar uses useAutoComplete composable
 * to generate content based on the topic extracted from existing nodes.
 * 
 * Auto-save functionality:
 * - Debounced auto-save on diagram changes (2 second delay)
 * - Auto-updates if diagram is already in library
 * - Auto-saves new diagrams if slots available
 * - Silently skips if slots full (user must manually save via File menu)
 */
import { computed, onMounted, onUnmounted, ref, watch } from 'vue'
import { useRoute } from 'vue-router'

import { AIModelSelector, CanvasToolbar, CanvasTopBar, ZoomControls } from '@/components/canvas'
import DiagramCanvas from '@/components/diagram/DiagramCanvas.vue'
import { eventBus, useLanguage, useNotifications } from '@/composables'
import { useAuthStore, useDiagramStore, useSavedDiagramsStore, useUIStore } from '@/stores'
import type { DiagramType } from '@/types'
import { authFetch } from '@/utils/api'

const route = useRoute()
const diagramStore = useDiagramStore()
const uiStore = useUIStore()
const authStore = useAuthStore()
const savedDiagramsStore = useSavedDiagramsStore()
const { isZh } = useLanguage()
const notify = useNotifications()

const isGenerating = ref(false)
const hasAutoGenerated = ref(false)
const customPrompt = ref<string | null>(null)

// Auto-save debounce timer
let autoSaveTimer: ReturnType<typeof setTimeout> | null = null
const AUTO_SAVE_DELAY = 2000 // 2 seconds debounce

// Map Chinese diagram type names to DiagramType
const diagramTypeMap: Record<string, DiagramType> = {
  圆圈图: 'circle_map',
  气泡图: 'bubble_map',
  双气泡图: 'double_bubble_map',
  树形图: 'tree_map',
  括号图: 'brace_map',
  流程图: 'flow_map',
  复流程图: 'multi_flow_map',
  桥型图: 'bridge_map',
  思维导图: 'mindmap',
  概念图: 'concept_map',
}

// Get diagram type from UI store (set before navigation)
const chartType = computed(() => uiStore.selectedChartType)

const diagramType = computed<DiagramType | null>(() => {
  if (!chartType.value) return null
  return diagramTypeMap[chartType.value] || null
})

/**
 * Generate diagram from a prompt
 * Used when user provides a prompt via DiagramTemplateInput
 */
async function generateDiagram(prompt: string) {
  if (!prompt.trim() || !diagramType.value) return

  isGenerating.value = true

  try {
    const response = await authFetch('/api/generate_graph', {
      method: 'POST',
      body: JSON.stringify({
        prompt: prompt.trim(),
        diagram_type: diagramType.value,
        language: isZh.value ? 'zh' : 'en',
        llm: 'qwen',
      }),
    })

    if (!response.ok) {
      const error = await response.json().catch(() => ({ detail: 'Failed to generate diagram' }))
      throw new Error(error.detail || 'Failed to generate diagram')
    }

    const result = await response.json()

    if (result.success && result.spec) {
      // Use diagram_type from response if available, otherwise use URL param
      const finalDiagramType = (result.diagram_type as DiagramType) || diagramType.value
      if (!finalDiagramType) {
        throw new Error('No diagram type specified')
      }

      // Load the spec into the diagram store
      const loaded = diagramStore.loadFromSpec(result.spec, finalDiagramType)
      if (loaded) {
        notify.success(isZh.value ? '图表生成成功' : 'Diagram generated successfully')
        // Emit rendered event for toolbar loading state reset
        eventBus.emit('diagram:rendered', {
          diagramType: finalDiagramType,
          nodeCount: diagramStore.nodeCount,
        })
      } else {
        throw new Error('Failed to load diagram data')
      }
    } else {
      throw new Error(result.error || 'Failed to generate diagram')
    }
  } catch (error) {
    console.error('Failed to generate diagram:', error)
    const errorMessage =
      error instanceof Error ? error.message : isZh.value ? '生成失败' : 'Generation failed'
    notify.error(errorMessage)
    // Emit failure event for toolbar loading state reset
    eventBus.emit('llm:generation_failed', { error: errorMessage })
  } finally {
    isGenerating.value = false
  }
}

function handleZoomChange(_level: number) {
  // Zoom is handled by DiagramCanvas
}

function handleFitToScreen() {
  // Fit view is handled by DiagramCanvas
}

function handleHandToolToggle(_active: boolean) {
  // Hand tool is handled by DiagramCanvas
}

function handleStartPresentation() {
  // TODO: Implement presentation mode
}

function handleModelChange(model: string) {
  // TODO: Handle AI model change
  console.log('Selected model:', model)
}

/**
 * Auto-generate diagram when user provided a prompt via template input
 * Only triggers if customPrompt is set (from canvas:generate_with_prompt event)
 */
async function autoGenerateDiagram() {
  if (!diagramType.value || hasAutoGenerated.value || isGenerating.value) return
  if (!customPrompt.value) return // Only auto-generate if prompt was provided

  hasAutoGenerated.value = true
  await generateDiagram(customPrompt.value)
}

// Listen for custom prompt from template input
const unsubPrompt = eventBus.onWithOwner(
  'canvas:generate_with_prompt',
  (data) => {
    if (data.prompt) {
      customPrompt.value = data.prompt as string
      // Reset auto-generation flag to allow regeneration
      hasAutoGenerated.value = false
      // Trigger auto-generation with custom prompt
      if (diagramType.value) {
        autoGenerateDiagram()
      }
    }
  },
  'CanvasPage'
)

// Watch for diagram type changes in store
watch(
  () => uiStore.selectedChartType,
  () => {
    // Reset auto-generation flag when type changes
    hasAutoGenerated.value = false

    if (diagramType.value) {
      diagramStore.setDiagramType(diagramType.value)
      // Load default template if we have a type and no existing diagram
      if (!diagramStore.data) {
        // Load static default template (no AI generation)
        diagramStore.loadDefaultTemplate(diagramType.value)
      }
    }
    // If no type specified, user should go back and select one
    // The canvas will show empty state
  },
  { immediate: true }
)

/**
 * Get the diagram title for auto-save
 * Uses topic node text or default name
 */
function getDiagramTitle(): string {
  const topicNode = diagramStore.data?.nodes?.find(
    (n) => n.type === 'topic' || n.type === 'center' || n.id === 'root'
  )
  if (topicNode?.text) {
    return topicNode.text
  }
  return isZh.value ? `未命名${chartType.value}` : `Untitled ${chartType.value}`
}

/**
 * Get diagram spec for saving
 */
function getDiagramSpec(): Record<string, unknown> | null {
  if (!diagramStore.data) return null
  
  return {
    type: diagramStore.type,
    nodes: diagramStore.data.nodes,
    connections: diagramStore.data.connections,
    _customPositions: diagramStore.data._customPositions,
    _node_styles: diagramStore.data._node_styles,
  }
}

/**
 * Perform auto-save of current diagram
 * Called after debounce delay when diagram changes
 */
async function performAutoSave(): Promise<void> {
  // Don't auto-save if not authenticated
  if (!authStore.isAuthenticated) return
  
  // Don't auto-save if no diagram data
  if (!diagramStore.type || !diagramStore.data) return
  
  // Don't auto-save while generating
  if (isGenerating.value) return

  const spec = getDiagramSpec()
  if (!spec) return

  const title = getDiagramTitle()

  try {
    const result = await savedDiagramsStore.autoSaveDiagram(
      title,
      diagramStore.type,
      spec,
      isZh.value ? 'zh' : 'en',
      null // TODO: Generate thumbnail
    )

    // Log result for debugging (can be removed in production)
    if (result.success) {
      console.log(`[CanvasPage] Auto-save ${result.action}: diagram ${result.diagramId}`)
    } else if (result.action === 'skipped') {
      // Silent skip when slots full - this is expected
      console.log('[CanvasPage] Auto-save skipped: no available slots')
    }
    // Don't show notifications for auto-save - it should be invisible to user
  } catch (error) {
    console.error('[CanvasPage] Auto-save error:', error)
  }
}

/**
 * Debounced auto-save trigger
 * Resets timer on each call, only executes after delay
 */
function triggerAutoSave(): void {
  if (autoSaveTimer) {
    clearTimeout(autoSaveTimer)
  }
  autoSaveTimer = setTimeout(performAutoSave, AUTO_SAVE_DELAY)
}

// Watch for diagram data changes to trigger auto-save
watch(
  () => diagramStore.data,
  (newData, oldData) => {
    // Only auto-save if we have data and it's changed
    if (newData && oldData) {
      triggerAutoSave()
    }
  },
  { deep: true }
)

// Load diagram from library if diagramId is in query
async function loadDiagramFromLibrary(diagramId: string): Promise<void> {
  const diagram = await savedDiagramsStore.getDiagram(diagramId)
  if (diagram) {
    // Set active diagram ID
    savedDiagramsStore.setActiveDiagram(diagramId)
    
    // Load the diagram into store
    const loaded = diagramStore.loadFromSpec(
      diagram.spec, 
      diagram.diagram_type as DiagramType
    )
    
    if (loaded) {
      uiStore.setSelectedChartType(
        Object.entries(diagramTypeMap).find(([_, v]) => v === diagram.diagram_type)?.[0] || 
        diagram.diagram_type
      )
    }
  }
}

onMounted(async () => {
  // Fetch diagrams to know current slot count
  await savedDiagramsStore.fetchDiagrams()
  
  // Check if loading a saved diagram from library
  const diagramId = route.query.diagramId
  if (diagramId) {
    await loadDiagramFromLibrary(String(diagramId))
    return // Don't load default template if loading from library
  }

  // Initialize diagram type from store
  if (diagramType.value) {
    diagramStore.setDiagramType(diagramType.value)
    // Load default template on mount if type is provided and no existing diagram
    if (!diagramStore.data) {
      // Load static default template (no AI generation)
      diagramStore.loadDefaultTemplate(diagramType.value)
    }
  }
  // If no type specified, canvas shows empty state
  // User should navigate back to select a diagram type
})

onUnmounted(() => {
  // Clear auto-save timer
  if (autoSaveTimer) {
    clearTimeout(autoSaveTimer)
    autoSaveTimer = null
  }
  
  unsubPrompt()
  // Clean up state when leaving canvas - matches old JS behavior
  diagramStore.reset()
  savedDiagramsStore.clearActiveDiagram()
  uiStore.setSelectedChartType('选择图示')
})
</script>

<template>
  <div class="canvas-page flex flex-col h-screen bg-gray-50">
    <!-- Top navigation bar -->
    <CanvasTopBar />

    <!-- Floating toolbar -->
    <CanvasToolbar />

    <!-- Main canvas area -->
    <div class="flex-1 relative overflow-hidden pt-16">
      <!-- Vue Flow Canvas -->
      <DiagramCanvas
        v-if="diagramStore.data"
        class="w-full h-full"
        :show-background="true"
        :show-controls="true"
        :show-minimap="false"
        :fit-view-on-init="true"
      />
    </div>

    <!-- Zoom controls (bottom right) -->
    <ZoomControls
      @zoom-change="handleZoomChange"
      @fit-to-screen="handleFitToScreen"
      @hand-tool-toggle="handleHandToolToggle"
      @start-presentation="handleStartPresentation"
    />

    <!-- AI model selector (bottom center) -->
    <AIModelSelector @model-change="handleModelChange" />
  </div>
</template>
